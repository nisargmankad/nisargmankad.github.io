@using MyPortfolio.Models
@using System.Net.Http.Json
@inject HttpClient Http
@inject IJSRuntime JS

<div class="card border-0">
  <div class="d-flex align-items-center justify-content-between mb-2">
    <h2 class="h4 mb-0">GitHub Activity</h2>
    <a class="small text-muted" target="_blank" rel="noopener"
       href=@($"https://github.com/{Username}")>@Username</a>
  </div>

  <div style="height: 280px;">
    <canvas id="@_canvasId" width="800" height="280"></canvas>
  </div>

  @if (!string.IsNullOrEmpty(_error))
  {
    <div class="alert alert-warning mt-3">@_error</div>
  }
</div>

@code {
  [Parameter] public string Username { get; set; } = "nisargmankad";
  [Parameter] public int Days { get; set; } = 90;

  private readonly string _canvasId = $"gh-activity-{Guid.NewGuid():N}";
  private string? _error;
  private readonly CancellationTokenSource _cts = new();

  // data to chart
  private List<string> _labels = [];
  private List<int> _values = [];
  private bool _dataReady = false;
  private bool _chartRendered = false;

  protected override async Task OnInitializedAsync()
  {
    try
    {
      if (!Http.DefaultRequestHeaders.UserAgent.Any())
      {
        Http.DefaultRequestHeaders.UserAgent.ParseAdd("MyPortfolioApp/1.0");
      }
      Http.DefaultRequestHeaders.Accept.ParseAdd("application/vnd.github+json");

      var maxPages = 3;
      var allEvents = new List<GithubEvent>();

      for (var page = 1; page <= maxPages; page++)
      {
        var url = $"https://api.github.com/users/{Username}/events?per_page=100&page={page}";
        var pageEvents = await Http.GetFromJsonAsync<List<GithubEvent>>(url, _cts.Token);
        if (pageEvents is null || pageEvents.Count == 0) break;
        allEvents.AddRange(pageEvents);
      }

      var endDate = DateTime.UtcNow.Date;
      var startDate = endDate.AddDays(-Days + 1);

      var daily = new Dictionary<DateTime, int>();
      for (var d = startDate; d <= endDate; d = d.AddDays(1))
        daily[d] = 0;

      foreach (var ev in allEvents)
      {
        if (ev.type != "PushEvent") continue;
        var day = ev.created_at.ToUniversalTime().Date;
        if (day < startDate || day > endDate) continue;

        var commitCount = ev.payload?.size
                          ?? ev.payload?.commits?.Count
                          ?? 0;

        if (daily.ContainsKey(day))
          daily[day] += commitCount;
      }

      _labels = [];
      _values = [];
      for (var d = startDate; d <= endDate; d = d.AddDays(1))
      {
        _labels.Add(d.ToString("MMM d"));
        _values.Add(daily[d]);
      }

      _dataReady = true;
      StateHasChanged(); // trigger first render with canvas present
    }
    catch (HttpRequestException)
    {
      _error = "Couldnâ€™t reach GitHub API. Try again later.";
    }
    catch (TaskCanceledException)
    {
      _error = "Request canceled.";
    }
    catch (Exception ex)
    {
      _error = $"Unexpected error: {ex.Message}";
    }
  }

  protected override async Task OnAfterRenderAsync(bool firstRender)
  {
    // Only attempt to draw when data is ready and we haven't drawn yet
    if (_dataReady && !_chartRendered)
    {
      try
      {
        await JS.InvokeVoidAsync("chartInterop.renderLineChart", _canvasId, _labels, _values);
        _chartRendered = true;
      }
      catch (JSException)
      {
        // If scripts haven't loaded yet for some reason, try once more on the next render
        await Task.Delay(50);
        StateHasChanged();
      }
    }
  }

  public void Dispose()
  {
    _cts.Cancel();
    _cts.Dispose();
  }
}
